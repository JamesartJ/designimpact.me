{"version":3,"sources":["webpack:///./node_modules/zen-observable-ts/lib/index.js","webpack:///./node_modules/zen-observable-ts/lib/zenObservable.js","webpack:///./node_modules/graphql/language/visitor.mjs","webpack:///./node_modules/graphql/language/printer.mjs","webpack:///./node_modules/apollo-link/lib/linkUtils.js","webpack:///./node_modules/apollo-link/lib/link.js","webpack:///./node_modules/apollo-utilities/lib/getFromAST.js","webpack:///./node_modules/zen-observable/index.js","webpack:///./node_modules/zen-observable/lib/Observable.js","webpack:///./node_modules/fast-json-stable-stringify/index.js"],"names":["lib","a","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","DirectiveDefinition","BREAK","isNode","maybeNode","Boolean","kind","getVisitFn","visitor","isLeaving","kindVisitor","kindSpecificVisitor","leave","enter","specificVisitor","specificKindVisitor","print","ast","root","visitorKeys","arguments","length","undefined","stack","inArray","Array","isArray","keys","index","edits","node","key","parent","path","ancestors","newRoot","isEdited","pop","slice","clone","k","hasOwnProperty","editOffset","ii","editKey","editValue","splice","prev","push","result","Error","JSON","stringify","visitFn","call","visit","printDocASTReducer","value","name","join","definitions","op","operation","varDefs","wrap","variableDefinitions","directives","selectionSet","_ref","variable","type","defaultValue","_ref2","block","selections","_ref3","alias","args","_ref4","_ref5","_ref6","typeCondition","_ref7","_ref8","_ref9","_ref10","isDescription","escaped","replace","indexOf","indent","printBlockString","_ref11","_ref12","_ref13","values","_ref14","fields","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","operationTypes","_ref21","addDescription","_ref22","_ref23","interfaces","_ref24","_ref25","_ref26","_ref27","types","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","locations","cb","description","maybeArray","separator","filter","x","array","start","maybeString","end","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","p","__","this","constructor","prototype","create","linkUtils_assign","assign","t","s","i","n","apply","LinkError","_super","message","link","_this","isTerminating","request","createOperation","starting","context","defineProperty","enumerable","next","query","variables","operationName","getKey","passthrough","forward","of","toLink","handler","ApolloLink","empty","from","links","map","reduce","y","concat","split","test","left","right","leftLink","rightLink","first","second","firstLink","console","warn","nextLink","execute","transformedOperation","extensions","definition","transformOperation","OPERATION_FIELDS","_i","_a","validateOperation","module","exports","__webpack_require__","Observable","_createClass","defineProperties","target","props","descriptor","configurable","writable","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","hasSymbols","Symbol","hasSymbol","getSymbol","observable","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","obj","getSpecies","ctor","isObservable","hostReportError","e","log","setTimeout","enqueue","fn","Promise","resolve","then","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","closeSubscription","_observer","_queue","_state","notifySubscription","observer","m","onNotify","queue","flushSubscription","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","error","get","_subscription","_subscriber","complete","reject","subscribe","done","_this2","_this3","_this4","C","hasSeed","hasValue","acc","_this5","_len","sources","_key","startNext","v","_this6","subscriptions","outer","inner","completeIfDone","closed","forEach","method","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","item","err","return","_len2","items","_key2","symbol","data","opts","cmp","f","cycles","aobj","bobj","seen","toJSON","isFinite","out","seenIndex","sort"],"mappings":"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","file":"2-473d89429736cf654b1d.js","sourcesContent":["import { Observable } from './zenObservable';\nexport * from './zenObservable';\nexport default Observable;\n//# sourceMappingURL=index.js.map","/* tslint:disable */\nimport zenObservable from 'zen-observable';\nexport var Observable = zenObservable;\n//# sourceMappingURL=zenObservable.js.map","\n\n/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nexport var QueryDocumentKeys = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name',\n  // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations']\n};\n\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n */\n\n\nexport var BREAK = {};\n\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n      var result = void 0;\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}","/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { visit } from './visitor';\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nexport function print(ast) {\n  return visit(ast, { leave: printDocASTReducer });\n}\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n\n  // Document\n\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet;\n    // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n\n\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue;\n    return variable + ': ' + type + wrap(' = ', defaultValue);\n  },\n\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n\n  // Fragments\n\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (\n      // Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      'fragment ' + name + wrap('(', join(variableDefinitions, ', '), ')') + ' ' + ('on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n\n  // Value\n\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n\n  // Directive\n\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n\n  // Type\n\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n\n  // Type System Definitions\n\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + wrap('(', join(args, ', '), ')') + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n\n  ScalarTypeExtension: function ScalarTypeExtension(_ref31) {\n    var name = _ref31.name,\n        directives = _ref31.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n\n  ObjectTypeExtension: function ObjectTypeExtension(_ref32) {\n    var name = _ref32.name,\n        interfaces = _ref32.interfaces,\n        directives = _ref32.directives,\n        fields = _ref32.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives,\n        fields = _ref33.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  UnionTypeExtension: function UnionTypeExtension(_ref34) {\n    var name = _ref34.name,\n        directives = _ref34.directives,\n        types = _ref34.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n\n  EnumTypeExtension: function EnumTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        values = _ref35.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        fields = _ref36.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  DirectiveDefinition: addDescription(function (_ref37) {\n    var name = _ref37.name,\n        args = _ref37.arguments,\n        locations = _ref37.locations;\n    return 'directive @' + name + wrap('(', join(args, ', '), ')') + ' on ' + join(locations, ' | ');\n  })\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription) {\n  var escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? '\"\"\"' + escaped.replace(/\"$/, '\"\\n') + '\"\"\"' : '\"\"\"\\n' + (isDescription ? escaped : indent(escaped)) + '\\n\"\"\"';\n}","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { getOperationName } from 'apollo-utilities';\nimport Observable from 'zen-observable-ts';\nimport { print } from 'graphql/language/printer';\nexport function validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        'query',\n        'operationName',\n        'variables',\n        'extensions',\n        'context',\n    ];\n    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw new Error(\"illegal argument: \" + key);\n        }\n    }\n    return operation;\n}\nvar LinkError = /** @class */ (function (_super) {\n    __extends(LinkError, _super);\n    function LinkError(message, link) {\n        var _this = _super.call(this, message) || this;\n        _this.link = link;\n        return _this;\n    }\n    return LinkError;\n}(Error));\nexport { LinkError };\nexport function isTerminating(link) {\n    return link.request.length <= 1;\n}\nexport function toPromise(observable) {\n    var completed = false;\n    return new Promise(function (resolve, reject) {\n        observable.subscribe({\n            next: function (data) {\n                if (completed) {\n                    console.warn(\"Promise Wrapper does not support multiple results from Observable\");\n                }\n                else {\n                    completed = true;\n                    resolve(data);\n                }\n            },\n            error: reject,\n        });\n    });\n}\n// backwards compat\nexport var makePromise = toPromise;\nexport function fromPromise(promise) {\n    return new Observable(function (observer) {\n        promise\n            .then(function (value) {\n            observer.next(value);\n            observer.complete();\n        })\n            .catch(observer.error.bind(observer));\n    });\n}\nexport function fromError(errorValue) {\n    return new Observable(function (observer) {\n        observer.error(errorValue);\n    });\n}\nexport function transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query,\n    };\n    // best guess at an operation name\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName =\n            typeof transformedOperation.query !== 'string'\n                ? getOperationName(transformedOperation.query)\n                : '';\n    }\n    return transformedOperation;\n}\nexport function createOperation(starting, operation) {\n    var context = __assign({}, starting);\n    var setContext = function (next) {\n        if (typeof next === 'function') {\n            context = __assign({}, context, next(context));\n        }\n        else {\n            context = __assign({}, context, next);\n        }\n    };\n    var getContext = function () { return (__assign({}, context)); };\n    Object.defineProperty(operation, 'setContext', {\n        enumerable: false,\n        value: setContext,\n    });\n    Object.defineProperty(operation, 'getContext', {\n        enumerable: false,\n        value: getContext,\n    });\n    Object.defineProperty(operation, 'toKey', {\n        enumerable: false,\n        value: function () { return getKey(operation); },\n    });\n    return operation;\n}\nexport function getKey(operation) {\n    // XXX we're assuming here that variables will be serialized in the same order.\n    // that might not always be true\n    return print(operation.query) + \"|\" + JSON.stringify(operation.variables) + \"|\" + operation.operationName;\n}\n//# sourceMappingURL=linkUtils.js.map","import Observable from 'zen-observable-ts';\nimport { validateOperation, isTerminating, LinkError, transformOperation, createOperation, } from './linkUtils';\nvar passthrough = function (op, forward) { return (forward ? forward(op) : Observable.of()); };\nvar toLink = function (handler) {\n    return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n};\nexport var empty = function () {\n    return new ApolloLink(function (op, forward) { return Observable.of(); });\n};\nexport var from = function (links) {\n    if (links.length === 0)\n        return empty();\n    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });\n};\nexport var split = function (test, left, right) {\n    if (right === void 0) { right = new ApolloLink(passthrough); }\n    var leftLink = toLink(left);\n    var rightLink = toLink(right);\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n        return new ApolloLink(function (operation) {\n            return test(operation)\n                ? leftLink.request(operation) || Observable.of()\n                : rightLink.request(operation) || Observable.of();\n        });\n    }\n    else {\n        return new ApolloLink(function (operation, forward) {\n            return test(operation)\n                ? leftLink.request(operation, forward) || Observable.of()\n                : rightLink.request(operation, forward) || Observable.of();\n        });\n    }\n};\n// join two Links together\nexport var concat = function (first, second) {\n    var firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n        console.warn(new LinkError(\"You are calling concat on a terminating link, which will have no effect\", firstLink));\n        return firstLink;\n    }\n    var nextLink = toLink(second);\n    if (isTerminating(nextLink)) {\n        return new ApolloLink(function (operation) {\n            return firstLink.request(operation, function (op) { return nextLink.request(op) || Observable.of(); }) || Observable.of();\n        });\n    }\n    else {\n        return new ApolloLink(function (operation, forward) {\n            return (firstLink.request(operation, function (op) {\n                return nextLink.request(op, forward) || Observable.of();\n            }) || Observable.of());\n        });\n    }\n};\nvar ApolloLink = /** @class */ (function () {\n    function ApolloLink(request) {\n        if (request)\n            this.request = request;\n    }\n    ApolloLink.prototype.split = function (test, left, right) {\n        if (right === void 0) { right = new ApolloLink(passthrough); }\n        return this.concat(split(test, left, right));\n    };\n    ApolloLink.prototype.concat = function (next) {\n        return concat(this, next);\n    };\n    ApolloLink.prototype.request = function (operation, forward) {\n        throw new Error('request is not implemented');\n    };\n    ApolloLink.empty = empty;\n    ApolloLink.from = from;\n    ApolloLink.split = split;\n    ApolloLink.execute = execute;\n    return ApolloLink;\n}());\nexport { ApolloLink };\nexport function execute(link, operation) {\n    return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());\n}\n//# sourceMappingURL=link.js.map","import { assign } from './util/assign';\nimport { valueToObjectRepresentation } from './storeUtils';\nexport function getMutationDefinition(doc) {\n    checkDocument(doc);\n    var mutationDef = doc.definitions.filter(function (definition) {\n        return definition.kind === 'OperationDefinition' &&\n            definition.operation === 'mutation';\n    })[0];\n    if (!mutationDef) {\n        throw new Error('Must contain a mutation definition.');\n    }\n    return mutationDef;\n}\nexport function checkDocument(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })\n        .map(function (definition) {\n        if (definition.kind !== 'OperationDefinition') {\n            throw new Error(\"Schema type definitions not allowed in queries. Found: \\\"\" + definition.kind + \"\\\"\");\n        }\n        return definition;\n    });\n    if (operations.length > 1) {\n        throw new Error(\"Ambiguous GraphQL document: contains \" + operations.length + \" operations\");\n    }\n}\nexport function getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];\n}\nexport function getOperationDefinitionOrDie(document) {\n    var def = getOperationDefinition(document);\n    if (!def) {\n        throw new Error(\"GraphQL document is missing an operation\");\n    }\n    return def;\n}\nexport function getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === 'OperationDefinition' && definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\nexport function getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });\n}\nexport function getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    if (!queryDef || queryDef.operation !== 'query') {\n        throw new Error('Must contain a query definition.');\n    }\n    return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    if (doc.definitions.length > 1) {\n        throw new Error('Fragment must have exactly one definition.');\n    }\n    var fragmentDef = doc.definitions[0];\n    if (fragmentDef.kind !== 'FragmentDefinition') {\n        throw new Error('Must be a fragment definition.');\n    }\n    return fragmentDef;\n}\nexport function getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' ||\n                operation === 'mutation' ||\n                operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\nexport function createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nexport function getDefaultValues(definition) {\n    if (definition &&\n        definition.variableDefinitions &&\n        definition.variableDefinitions.length) {\n        var defaultValues = definition.variableDefinitions\n            .filter(function (_a) {\n            var defaultValue = _a.defaultValue;\n            return defaultValue;\n        })\n            .map(function (_a) {\n            var variable = _a.variable, defaultValue = _a.defaultValue;\n            var defaultValueObj = {};\n            valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);\n            return defaultValueObj;\n        });\n        return assign.apply(void 0, [{}].concat(defaultValues));\n    }\n    return {};\n}\nexport function variablesInOperation(operation) {\n    var names = new Set();\n    if (operation.variableDefinitions) {\n        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            names.add(definition.variable.name.value);\n        }\n    }\n    return names;\n}\n//# sourceMappingURL=getFromAST.js.map","module.exports = require('./lib/Observable.js').Observable;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// === Symbol Support ===\n\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species');\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) return undefined;\n\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({ type: type, value: value });\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{ type: type, value: value }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: 'next',\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: 'error',\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: 'complete',\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = exports.Observable = function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: 'subscribe',\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: 'map',\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'filter',\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'concat',\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscription = void 0;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: 'flatMap',\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: SymbolObservable,\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: 'from',\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n\n      if (x == null) throw new TypeError(x + ' is not an object');\n\n      var method = getMethod(x, SymbolObservable);\n      if (method) {\n        var observable = method.call(x);\n\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n\n        if (isObservable(observable) && observable.constructor === C) return observable;\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, SymbolIterator);\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var item = _step.value;\n\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: 'of',\n    value: function of() {\n      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n"],"sourceRoot":""}